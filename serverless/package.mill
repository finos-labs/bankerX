
package build.serverless
import mill._, scalalib._
import $file.versions.V 
import $file.util.BankerXScalaModule

object `package` extends RootModule with BankerXScalaModule {
  //def moduleDeps = Seq(build.bar.qux.mymodule)
  def ivyDeps = Agg(
    ivy"com.softwaremill.sttp.tapir::tapir-aws-lambda-zio::${V.Libs.tapir}",
    ivy"dev.zio::zio::${V.Libs.zio}",
    ivy"com.softwaremill.sttp.tapir::tapir-jsoniter-scala:${V.Libs.tapir}",
    ivy"com.github.plokhotnyuk.jsoniter-scala::jsoniter-scala-core:${V.Libs.`jsoniter-scala`}",
    ivy"com.github.plokhotnyuk.jsoniter-scala::jsoniter-scala-macros:${V.Libs.`jsoniter-scala`}",
  )

  def cdkSynth = T {
    val workingDir = prepareCdkForSynth().path
    os.proc("npx", "cdk", "synth").call(cwd = workingDir)
    PathRef(workingDir / "cdk.out")
  }

  def cdk = T{T.dest}

  def generateCdk = T {
    val workingDir = cdk()
    val outputDir = workingDir / "cdk"
    val codeArtifact = assembly().path 
    val _ = allSourceFiles()
    val args = Seq("--code-location", codeArtifact.toString)
    runner().run(args = args, workingDir = workingDir)    
    PathRef(outputDir)
  }

  def generatedCdkSources = T.source { generateCdk() }

  def npmInstallCdk = T {
    val workingDir = generatedCdkSources().path
    os.proc("npm", "install").call(cwd = workingDir)
    Map(
      "node_modules" -> PathRef(workingDir / "node_modules"),
      "cdk" -> PathRef(workingDir)
    )
  }

  def prepareCdkForSynth = T {
    val _ = npmInstallCdk()
    PathRef(generatedCdkSources().path)
  }
}